var searchIndex = {};
searchIndex['flac'] = {"items":[[0,"","flac","An implementation of [FLAC](https://xiph.org/flac), free lossless audio\ncodec, written in Rust.",null,null],[3,"Stream","","",null,null],[12,"info","","",0,null],[12,"metadata","","",0,null],[12,"frames","","",0,null],[0,"metadata","","Provides an interface for dealing with FLAC metadata blocks.",null,null],[3,"Block","flac::metadata","Data associated with a single metadata block.",null,null],[12,"is_last","","Marks whether the current metadata block is the last.",1,null],[12,"length","","The length, in bytes, of the block being parsed. This does not include\nthe metadata block header.",1,null],[12,"data","","Block data containing one of the eight different types of metadata.",1,null],[3,"StreamInfo","","Information regarding the entire audio stream.",null,null],[12,"min_block_size","","Minimum block size, in samples, used in the stream.",2,null],[12,"max_block_size","","Maximum block size, in samples, used in the stream.",2,null],[12,"min_frame_size","","Minimum frame size, in bytes, used in the stream. May be zero to imply\nthe value isn't know.",2,null],[12,"max_frame_size","","Maximum frame size, in bytes, used in the stream. May be zero to imply\nthe value isn't know.",2,null],[12,"sample_rate","","Sample rate in hertz (Hz).",2,null],[12,"channels","","Number of channels. FLAC supports one to eight channel.",2,null],[12,"bits_per_sample","","Bits per sample. FLAC supports four to thirty-two bits per sample.",2,null],[12,"total_samples","","Total samples in the stream. A value of zero means the number is\nunknown.",2,null],[12,"md5_sum","","MD5 signature of the unencoded audio data.",2,null],[3,"Application","","Data used by third-party applications.",null,null],[12,"id","","Registered application ID.",3,null],[12,"data","","Data used by the third-party application.",3,null],[3,"VorbisComment","","Stores human-readable name/value pairs.",null,null],[12,"vendor_string","","Vendor name.",4,null],[12,"comments","","Comments associated with a name, or category, followed by it's\ncontents.",4,null],[3,"CueSheet","","Stores cue information.",null,null],[12,"media_catalog_number","","Media catalog number.",5,null],[12,"lead_in","","Number of lead-in samples.",5,null],[12,"is_cd","","Whether or not this `CueSheet` corresponds to a Compact Disc.",5,null],[12,"tracks","","One or more tracks.",5,null],[3,"Picture","","Stores pictures associated with the FLAC file.",null,null],[12,"picture_type","","Picture type, based on the ID3v2 APIC frame.",6,null],[12,"mime_type","","Multipurpose Internet Mail Extensions (MIME) type.",6,null],[12,"description","","A string describing the picture.",6,null],[12,"width","","Width of the picture in pixels.",6,null],[12,"height","","Height of the picture in pixels.",6,null],[12,"depth","","Color depth of the picture in bits-per-pixel.",6,null],[12,"colors","","Number of colors used.",6,null],[12,"data","","Binary picture data.",6,null],[3,"SeekPoint","","Seek, or skip, to a point within the FLAC file.",null,null],[12,"sample_number","","Sample number of the first sample in the target frame.",7,null],[12,"stream_offset","","Byte offset of the target frame's header.",7,null],[12,"frame_samples","","Number of samples in the target frame.",7,null],[3,"CueSheetTrack","","Track information inside a cue sheet.",null,null],[12,"offset","","Track offset, in samples, relative to the beginning of the FLAC audio\nstream.",8,null],[12,"number","","Track number.",8,null],[12,"isrc","","Twelve digit alphanumeric code.",8,null],[12,"is_audio","","Whether the cue sheet track is audio.",8,null],[12,"is_pre_emphasis","","Whether the cue sheet track is pre-emphasis.",8,null],[12,"indices","","For all tracks except the lead-out track.",8,null],[3,"CueSheetTrackIndex","","An index point within a track, inside of a cue sheet.",null,null],[12,"offset","","Offset, in samples, relative to the track offset of the index point.",9,null],[12,"number","","Index point number.",9,null],[4,"BlockData","","General enum that hold all the different metadata block data.",null,null],[13,"StreamInfo","","Information regarding the entire audio stream.",10,null],[13,"Padding","","Block that represents a number of padded bytes.",10,null],[13,"Application","","Data used by third-party applications.",10,null],[13,"SeekTable","","Table of multiple points to seek, or skip, to within the FLAC file.",10,null],[13,"VorbisComment","","Stores human-readable name/value pairs.",10,null],[13,"CueSheet","","Stores cue information",10,null],[13,"Picture","","Stores pictures associated with the FLAC file.",10,null],[13,"Unknown","","A type of block data that isn't know or doesn't match the type above.",10,null],[4,"PictureType","","The picture type according to the ID3v2 attached picture frame.",null,null],[13,"Other","","Other picture type not categorized in this enum.",11,null],[13,"FileIconStandard","","32x32 pixels 'file icon'.",11,null],[13,"FileIcon","","Other, or non-standard, file icon.",11,null],[13,"FrontCover","","Cover (front).",11,null],[13,"BackCover","","Cover (back).",11,null],[13,"LeafletPage","","Leaflet page.",11,null],[13,"Media","","Media, like label side of a CD.",11,null],[13,"LeadArtist","","Lead artist, lead performer, or soloist.",11,null],[13,"Artist","","Artist or performer.",11,null],[13,"Conductor","","Conductor.",11,null],[13,"Band","","Band or orchestra.",11,null],[13,"Composer","","Composer.",11,null],[13,"Lyricist","","Lyricist or text writer.",11,null],[13,"RecordingLocation","","Recording location.",11,null],[13,"DuringRecording","","During recording.",11,null],[13,"DuringPerformace","","During performance.",11,null],[13,"VideoScreenCapture","","Movie, or video, screen capture.",11,null],[13,"Fish","","A bright colored fish.",11,null],[13,"Illustration","","Illustration.",11,null],[13,"BandLogo","","Band, or artist, logotype.",11,null],[13,"PublisherLogo","","Publisher, or studio, logotype.",11,null],[5,"metadata_parser","","Parses all metadata within a file stream.",null,null],[5,"get_stream_info","","Reads and returns the `StreamInfo` metadata block of the given FLAC\nfile.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"get_vorbis_comment","","Reads and returns the `VorbisComment` metadata block of the given FLAC\nfile.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"get_cue_sheet","","Reads and returns the `CueSheet` metadata block of the given FLAC file.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"get_picture","","Reads and returns a `Picture` metadata block of the given FLAC file.",null,{"inputs":[{"name":"str"},{"name":"option"},{"name":"option"},{"name":"option"},{"name":"option"},{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"block"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"blockdata"},{"name":"blockdata"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"blockdata"},{"name":"blockdata"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"blockdata"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"streaminfo"},{"name":"streaminfo"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"streaminfo"},{"name":"streaminfo"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"streaminfo"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",2,{"inputs":[{"name":"streaminfo"}],"output":{"name":"streaminfo"}}],[11,"eq","","",3,{"inputs":[{"name":"application"},{"name":"application"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"application"},{"name":"application"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"application"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",7,{"inputs":[{"name":"seekpoint"},{"name":"seekpoint"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"seekpoint"},{"name":"seekpoint"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"seekpoint"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"vorbiscomment"},{"name":"vorbiscomment"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"vorbiscomment"},{"name":"vorbiscomment"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"vorbiscomment"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"cuesheet"},{"name":"cuesheet"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"cuesheet"},{"name":"cuesheet"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"cuesheet"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"cuesheettrack"},{"name":"cuesheettrack"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"cuesheettrack"},{"name":"cuesheettrack"}],"output":{"name":"bool"}}],[11,"fmt","","",8,{"inputs":[{"name":"cuesheettrack"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"cuesheettrackindex"},{"name":"cuesheettrackindex"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"cuesheettrackindex"},{"name":"cuesheettrackindex"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"cuesheettrackindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"picture"},{"name":"picture"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"picture"},{"name":"picture"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"picture"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"picturetype"}],"output":{"name":"picturetype"}}],[11,"eq","","",11,{"inputs":[{"name":"picturetype"},{"name":"picturetype"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"picturetype"},{"name":"picturetype"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"picturetype"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"frame","flac","",null,null],[3,"Frame","flac::frame","Audio frame that contains one sample for each channel.",null,null],[12,"header","","Information regarding the current audio frame.",12,null],[12,"subframes","","Data for each audio channel.",12,null],[12,"footer","","CRC-16 of all frame bytes before this footer.",12,null],[3,"Header","","Information regarding the current audio frame.",null,null],[12,"block_size","","Number of samples per subframe.",13,null],[12,"sample_rate","","Sample rate in hertz (Hz).",13,null],[12,"channels","","Number of channels that also represent the number of subframes.",13,null],[12,"channel_assignment","","Channel assignment order.",13,null],[12,"bits_per_sample","","Size, in bits, per sample.",13,null],[12,"number","","Numbering scheme used from the frame.",13,null],[12,"crc","","CRC-8 of all header bytes before this crc.",13,null],[3,"Footer","","End of the audio frame.",null,null],[4,"ChannelAssignment","","Channel assignment order.",null,null],[13,"Independent","","Independent channels, from one up to eight.",14,null],[13,"LeftSide","","Left and side stereo.",14,null],[13,"RightSide","","Right and side stereo.",14,null],[13,"MiddleSide","","Middle and side stereo.",14,null],[4,"NumberType","","Numbering scheme used from the frame.",null,null],[13,"Frame","","Frame number of first sample in frame.",15,null],[13,"Sample","","Sample number of first sample in frame.",15,null],[5,"frame_parser","","Parses an audio frame",null,null],[11,"eq","","",14,{"inputs":[{"name":"channelassignment"},{"name":"channelassignment"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"channelassignment"},{"name":"channelassignment"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"channelassignment"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"channelassignment"}],"output":{"name":"channelassignment"}}],[11,"eq","","",15,{"inputs":[{"name":"numbertype"},{"name":"numbertype"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"numbertype"},{"name":"numbertype"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"numbertype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"numbertype"}],"output":{"name":"numbertype"}}],[11,"eq","","",13,{"inputs":[{"name":"header"},{"name":"header"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"header"},{"name":"header"}],"output":{"name":"bool"}}],[11,"fmt","","",13,{"inputs":[{"name":"header"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"footer"},{"name":"footer"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"footer"},{"name":"footer"}],"output":{"name":"bool"}}],[11,"fmt","","",16,{"inputs":[{"name":"footer"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"subframe","","",null,null],[3,"SubFrame","flac::frame::subframe","A single channel of audio data.",null,null],[12,"data","","Data containing one of the four different types of subframes.",17,null],[12,"wasted_bits","","Number of wasted bits within each sample.",17,null],[3,"Fixed","","Fixed linear prediction subframe.",null,null],[12,"entropy_coding_method","","Residual coding method.",18,null],[12,"order","","Polynomial order.",18,null],[12,"warmup","","Samples used to warm up, or prime, the predictor.",18,null],[12,"residual","","Remaining samples after the warm up samples.",18,null],[3,"LPC","","Finite Impulse Response (FIR) linear prediction subframe.",null,null],[12,"entropy_coding_method","","Residual coding method.",19,null],[12,"order","","FIR order.",19,null],[12,"qlp_coeff_precision","","Quantized FIR filter coefficient precision in bits.",19,null],[12,"quantization_level","","Quantized linear predictor coefficient shift needed in bits.",19,null],[12,"qlp_coefficients","","FIR filter coefficients.",19,null],[12,"warmup","","Samples used to warm up, or prime, the predictor.",19,null],[12,"residual","","Remaining samples after the warm up samples.",19,null],[3,"EntropyCodingMethod","","Header for the entropy coding method.",null,null],[12,"method_type","","The type of coding method being used.",20,null],[12,"data","","Data for each entropy coding method partition.",20,null],[3,"PartitionedRice","","Header for a Rice partitioned residual.",null,null],[12,"order","","Partition order.",21,null],[12,"contents","","Rice parameters and/or raw bits.",21,null],[3,"PartitionedRiceContents","","Contents of a Rice partitioned residual.",null,null],[12,"parameters","","Rice parameters for each context.",22,null],[12,"raw_bits","","Widths for escaped-coded partitions.",22,null],[4,"Data","","General enum that holds all the different subframe data types.",null,null],[13,"Constant","","A single value that represents a constant subframe.",23,null],[13,"Verbatim","","An uncompressed subframe.",23,null],[13,"Fixed","","Fixed linear prediction subframe.",23,null],[13,"LPC","","FIR linear prediction subframe.",23,null],[4,"CodingMethod","","The available entropy coding methods.",null,null],[13,"PartitionedRice","","Coding partition with a 4-bit Rice parameter.",24,null],[13,"PartitionedRice2","","Coding partition with a 5-bit Rice parameter.",24,null],[5,"subframe_parser","","Parse a single channel of audio data.",null,null],[11,"eq","","",23,{"inputs":[{"name":"data"},{"name":"data"}],"output":{"name":"bool"}}],[11,"ne","","",23,{"inputs":[{"name":"data"},{"name":"data"}],"output":{"name":"bool"}}],[11,"fmt","","",23,{"inputs":[{"name":"data"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",18,{"inputs":[{"name":"fixed"},{"name":"fixed"}],"output":{"name":"bool"}}],[11,"ne","","",18,{"inputs":[{"name":"fixed"},{"name":"fixed"}],"output":{"name":"bool"}}],[11,"fmt","","",18,{"inputs":[{"name":"fixed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",19,{"inputs":[{"name":"lpc"},{"name":"lpc"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"lpc"},{"name":"lpc"}],"output":{"name":"bool"}}],[11,"fmt","","",19,{"inputs":[{"name":"lpc"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",20,{"inputs":[{"name":"entropycodingmethod"},{"name":"entropycodingmethod"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"entropycodingmethod"},{"name":"entropycodingmethod"}],"output":{"name":"bool"}}],[11,"fmt","","",20,{"inputs":[{"name":"entropycodingmethod"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"codingmethod"}],"output":{"name":"codingmethod"}}],[11,"eq","","",24,{"inputs":[{"name":"codingmethod"},{"name":"codingmethod"}],"output":{"name":"bool"}}],[11,"ne","","",24,{"inputs":[{"name":"codingmethod"},{"name":"codingmethod"}],"output":{"name":"bool"}}],[11,"fmt","","",24,{"inputs":[{"name":"codingmethod"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",21,{"inputs":[{"name":"partitionedrice"},{"name":"partitionedrice"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"partitionedrice"},{"name":"partitionedrice"}],"output":{"name":"bool"}}],[11,"fmt","","",21,{"inputs":[{"name":"partitionedrice"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",22,{"inputs":[{"name":"partitionedricecontents"},{"name":"partitionedricecontents"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"partitionedricecontents"},{"name":"partitionedricecontents"}],"output":{"name":"bool"}}],[11,"fmt","","",22,{"inputs":[{"name":"partitionedricecontents"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",22,{"inputs":[{"name":"partitionedricecontents"},{"name":"usize"}],"output":{"name":"partitionedricecontents"}}],[17,"MAX_FIXED_ORDER","","Maximum order of the fixed predictors permitted by the format.",null,null],[17,"MAX_LPC_ORDER","","Maximum LPC order permitted by the format.",null,null],[17,"MAX_CHANNELS","flac::frame","Maximum number of channels supported in the FLAC format.",null,null]],"paths":[[3,"Stream"],[3,"Block"],[3,"StreamInfo"],[3,"Application"],[3,"VorbisComment"],[3,"CueSheet"],[3,"Picture"],[3,"SeekPoint"],[3,"CueSheetTrack"],[3,"CueSheetTrackIndex"],[4,"BlockData"],[4,"PictureType"],[3,"Frame"],[3,"Header"],[4,"ChannelAssignment"],[4,"NumberType"],[3,"Footer"],[3,"SubFrame"],[3,"Fixed"],[3,"LPC"],[3,"EntropyCodingMethod"],[3,"PartitionedRice"],[3,"PartitionedRiceContents"],[4,"Data"],[4,"CodingMethod"]]};
searchIndex['nom'] = {"items":[[0,"","nom","Nom, eating data byte by byte",null,null],[3,"AccReader","","",null,null],[3,"FileProducer","","Can produce data from a file",null,null],[3,"MemProducer","","Can parse data from an already in memory byte array",null,null],[3,"ReadProducer","","Can produce data from a struct implementing Read",null,null],[3,"Stepper","","Wraps a producer. The `step` method applies a parser and returns its result",null,null],[4,"ErrorCode","","indicates which parser returned an error",null,null],[13,"Tag","","",0,null],[13,"MapRes","","",0,null],[13,"MapOpt","","",0,null],[13,"Alt","","",0,null],[13,"IsNot","","",0,null],[13,"IsA","","",0,null],[13,"Filter","","",0,null],[13,"SeparatedList","","",0,null],[13,"SeparatedNonEmptyList","","",0,null],[13,"Many1","","",0,null],[13,"Count","","",0,null],[13,"TakeUntilAndConsume","","",0,null],[13,"TakeUntil","","",0,null],[13,"TakeUntilEitherAndConsume","","",0,null],[13,"TakeUntilEither","","",0,null],[13,"LengthValue","","",0,null],[13,"TagClosure","","",0,null],[13,"Alpha","","",0,null],[13,"Digit","","",0,null],[13,"AlphaNumeric","","",0,null],[13,"Space","","",0,null],[13,"MultiSpace","","",0,null],[13,"LengthValueFn","","",0,null],[13,"Eof","","",0,null],[13,"ExprOpt","","",0,null],[13,"ExprRes","","",0,null],[13,"CondReduce","","",0,null],[13,"Switch","","",0,null],[13,"TagBits","","",0,null],[13,"OneOf","","",0,null],[13,"NoneOf","","",0,null],[13,"Char","","",0,null],[13,"CrLf","","",0,null],[13,"RegexpMatch","","",0,null],[13,"RegexpMatches","","",0,null],[13,"RegexpFind","","",0,null],[13,"RegexpCapture","","",0,null],[13,"RegexpCaptures","","",0,null],[13,"TakeWhile1","","",0,null],[4,"Err","","Contains the error that a parser can return",null,null],[13,"Code","","an error code",1,null],[13,"Node","","an error code, and the next error in the parsing chain",1,null],[13,"Position","","an error code and the related input position",1,null],[13,"NodePosition","","an error code, the related input position, and the next error in the parsing chain",1,null],[4,"Needed","","Contains information on needed data if a parser returned `Incomplete`",null,null],[13,"Unknown","","needs more data, but we do not know how much",2,null],[13,"Size","","contains the required data size",2,null],[4,"IResult","","Holds the result of parsing functions",null,null],[13,"Done","","",3,null],[13,"Error","","",3,null],[13,"Incomplete","","",3,null],[4,"ProducerState","","Holds the data producer's current state",null,null],[13,"Eof","","",4,null],[13,"Continue","","",4,null],[13,"Data","","",4,null],[13,"ProducerError","","",4,null],[4,"StepperState","","Holds the Stepper's current state",null,null],[13,"Eof","","",5,null],[13,"Value","","",5,null],[13,"ProducerError","","",5,null],[13,"Continue","","",5,null],[13,"ParserError","","",5,null],[4,"ConsumerState","","Holds the current state of the consumer",null,null],[13,"Await","","",6,null],[13,"Seek","","",6,null],[13,"Incomplete","","",6,null],[13,"ConsumerDone","","",6,null],[13,"ConsumerError","","",6,null],[5,"error_to_list","","",null,{"inputs":[{"name":"err"}],"output":{"name":"vec"}}],[5,"compare_error_paths","","",null,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[5,"add_error_pattern","","",null,{"inputs":[{"name":"hashmap"},{"name":"iresult"},{"name":"str"}],"output":{"name":"bool"}}],[5,"slice_to_offsets","","",null,null],[5,"prepare_errors","","",null,null],[5,"print_error","","",null,null],[5,"generate_colors","","",null,{"inputs":[{"name":"vec"}],"output":{"name":"hashmap"}}],[5,"code_from_offset","","",null,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"option"}}],[5,"reset_color","","",null,{"inputs":[{"name":"vec"}],"output":null}],[5,"write_color","","",null,{"inputs":[{"name":"vec"},{"name":"u8"}],"output":null}],[5,"print_codes","","",null,{"inputs":[{"name":"hashmap"},{"name":"hashmap"}],"output":{"name":"string"}}],[5,"print_offsets","","",null,null],[5,"tag_cl","","",null,null],[5,"print","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"begin","","",null,null],[5,"not_line_ending","","",null,null],[5,"line_ending","","Recognizes a line feed",null,null],[5,"is_alphabetic","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_space","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"alpha","","Recognizes lowercase and uppercase alphabetic characters: a-zA-Z",null,null],[5,"digit","","Recognizes numerical characters: 0-9",null,null],[5,"alphanumeric","","Recognizes numerical and alphabetic characters: 0-9a-zA-Z",null,null],[5,"space","","Recognizes spaces and tabs",null,null],[5,"multispace","","Recognizes spaces, tabs, carriage returns and line feeds",null,null],[5,"sized_buffer","","",null,null],[5,"length_value","","",null,null],[5,"be_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"be_u16","","Recognizes big endian unsigned 2 bytes integer",null,null],[5,"be_u32","","Recognizes big endian unsigned 4 bytes integer",null,null],[5,"be_u64","","Recognizes big endian unsigned 8 bytes integer",null,null],[5,"be_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"be_i16","","Recognizes big endian signed 2 bytes integer",null,null],[5,"be_i32","","Recognizes big endian signed 4 bytes integer",null,null],[5,"be_i64","","Recognizes big endian signed 8 bytes integer",null,null],[5,"le_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"le_u16","","Recognizes little endian unsigned 2 bytes integer",null,null],[5,"le_u32","","Recognizes little endian unsigned 4 bytes integer",null,null],[5,"le_u64","","Recognizes little endian unsigned 8 bytes integer",null,null],[5,"le_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"le_i16","","Recognizes little endian signed 2 bytes integer",null,null],[5,"le_i32","","Recognizes little endian signed 4 bytes integer",null,null],[5,"le_i64","","Recognizes little endian signed 8 bytes integer",null,null],[5,"be_f32","","Recognizes big endian 4 bytes floating point number",null,null],[5,"be_f64","","Recognizes big endian 8 bytes floating point number",null,null],[5,"eof","","Recognizes empty input buffers",null,null],[5,"rest","","Return the remaining input.",null,null],[5,"newline","","",null,null],[5,"crlf","","",null,null],[5,"eol","","",null,null],[5,"tab","","",null,null],[5,"anychar","","",null,null],[11,"clone","","",1,{"inputs":[{"name":"err"}],"output":{"name":"err"}}],[11,"eq","","",1,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"err"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"needed"}],"output":{"name":"needed"}}],[11,"eq","","",2,{"inputs":[{"name":"needed"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"needed"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"needed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"iresult"}}],[11,"eq","","",3,{"inputs":[{"name":"iresult"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"iresult"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"iresult"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_done","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"is_err","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"is_incomplete","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"new","","",7,{"inputs":[{"name":"accreader"},{"name":"r"}],"output":{"name":"accreader"}}],[11,"with_capacity","","",7,{"inputs":[{"name":"accreader"},{"name":"usize"},{"name":"r"}],"output":{"name":"accreader"}}],[11,"get_ref","","Gets a reference to the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"get_mut","","Gets a mutable reference to the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"into_inner","","Unwraps this `AccReader`, returning the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"reset_buffer_position","","",7,{"inputs":[{"name":"accreader"}],"output":null}],[11,"current_slice","","",7,null],[11,"capacity","","",7,{"inputs":[{"name":"accreader"}],"output":{"name":"usize"}}],[11,"read","","",7,null],[11,"fill_buf","","",7,{"inputs":[{"name":"accreader"}],"output":{"name":"result"}}],[11,"consume","","",7,{"inputs":[{"name":"accreader"},{"name":"usize"}],"output":null}],[11,"eq","","",4,{"inputs":[{"name":"producerstate"},{"name":"producerstate"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"producerstate"},{"name":"producerstate"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"producerstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",8,{"inputs":[{"name":"fileproducer"},{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"produce","","",8,{"inputs":[{"name":"fileproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",8,{"inputs":[{"name":"fileproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"new","","",9,null],[11,"produce","","",9,{"inputs":[{"name":"memproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",9,{"inputs":[{"name":"memproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"new","","",10,{"inputs":[{"name":"readproducer"},{"name":"t"},{"name":"usize"}],"output":{"name":"readproducer"}}],[11,"produce","","",10,{"inputs":[{"name":"readproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",10,{"inputs":[{"name":"readproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"eq","","",5,{"inputs":[{"name":"stepperstate"},{"name":"stepperstate"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"stepperstate"},{"name":"stepperstate"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"stepperstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",11,{"inputs":[{"name":"stepper"},{"name":"t"}],"output":{"name":"stepper"}}],[11,"step","","",11,{"inputs":[{"name":"stepper"},{"name":"f"}],"output":{"name":"stepperstate"}}],[11,"clone","","",6,{"inputs":[{"name":"consumerstate"}],"output":{"name":"consumerstate"}}],[11,"eq","","",6,{"inputs":[{"name":"consumerstate"},{"name":"consumerstate"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"consumerstate"},{"name":"consumerstate"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"consumerstate"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"HexDisplay","","useful functions to calculate the offset between slices and show a hexdump of a slice",null,null],[10,"offset","","offset between the first byte of self and the first byte of the argument",12,null],[10,"to_hex","","Converts the value of `self` to a hex dump, returning the owned\nstring.",12,{"inputs":[{"name":"hexdisplay"},{"name":"usize"}],"output":{"name":"string"}}],[10,"to_hex_from","","Converts the value of `self` to a hex dump beginning at `from` address, returning the owned\nstring.",12,{"inputs":[{"name":"hexdisplay"},{"name":"usize"},{"name":"usize"}],"output":{"name":"string"}}],[8,"AsBytes","","",null,null],[10,"as_bytes","","",13,null],[8,"GetInput","","",null,null],[10,"remaining_input","","",14,{"inputs":[{"name":"getinput"}],"output":{"name":"option"}}],[8,"GetOutput","","",null,null],[10,"output","","",15,{"inputs":[{"name":"getoutput"}],"output":{"name":"option"}}],[8,"Producer","","A producer implements the produce method, currently working with u8 arrays",null,null],[10,"produce","","",16,{"inputs":[{"name":"producer"}],"output":{"name":"producerstate"}}],[10,"seek","","",16,{"inputs":[{"name":"producer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[8,"Consumer","","Implement the consume method, taking a byte array as input and returning a consumer state",null,null],[10,"consume","","",17,null],[10,"failed","","",17,{"inputs":[{"name":"consumer"},{"name":"u32"}],"output":null}],[10,"end","","",17,{"inputs":[{"name":"consumer"}],"output":null}],[11,"run","","",17,{"inputs":[{"name":"consumer"},{"name":"producer"}],"output":null}],[14,"dbg!","","Prints a message if the parser fails",null,null],[14,"dbg_dmp!","","Prints a message and the input if the parser fails",null,null],[14,"closure!","","Wraps a parser in a closure",null,null],[14,"named!","","Makes a function from a parser combination",null,null],[14,"call!","","Used to wrap common expressions and function as macros",null,null],[14,"apply!","","emulate function currying: `apply!(my_function, arg1, arg2, ...)` becomes `my_function(input, arg1, arg2, ...)`",null,null],[14,"error!","","Prevents backtracking if the child parser fails",null,null],[14,"flat_map!","","`flat_map!(R -> IResult<R,S>, S -> IResult<S,T>) => R -> IResult<R, T>`",null,null],[14,"map!","","`map!(I -> IResult<I,O>, O -> P) => I -> IResult<I, P>`\nmaps a function on the result of a parser",null,null],[14,"map_impl!","","Internal parser, do not use directly",null,null],[14,"map_res!","","`map_res!(I -> IResult<I,O>, O -> Result<P>) => I -> IResult<I, P>`\nmaps a function returning a Result on the output of a parser",null,null],[14,"map_res_impl!","","Internal parser, do not use directly",null,null],[14,"map_opt!","","`map_res!(I -> IResult<I,O>, O -> Option<P>) => I -> IResult<I, P>`\nmaps a function returning an Option on the output of a parser",null,null],[14,"map_opt_impl!","","Internal parser, do not use directly",null,null],[14,"expr_res!","","`expr_res!(Result<E,O>) => I -> IResult<I, O>`\nevaluate an expression that returns a Result<T,E> and returns a IResult::Done(I,T) if Ok",null,null],[14,"expr_opt!","","`expr_opt!(Option<O>) => I -> IResult<I, O>`\nevaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Ok",null,null],[14,"chain!","","`chain!(I->IResult<I,A> ~ I->IResult<I,B> ~ ... I->IResult<I,X> , || { return O } ) => I -> IResult<I, O>`\nchains parsers and assemble the results through a closure",null,null],[14,"chaining_parser!","","Internal parser, do not use directly",null,null],[14,"alt!","","`alt!(I -> IResult<I,O> | I -> IResult<I,O> | ... | I -> IResult<I,O> ) => I -> IResult<I, O>`\ntry a list of parsers, return the result of the first successful one",null,null],[14,"alt_parser!","","Internal parser, do not use directly",null,null],[14,"switch!","","`switch!(I -> IResult<I,P>, P => I -> IResult<I,O> | ... | P => I -> IResult<I,O> ) => I -> IResult<I, O>`\nchoose the next parser depending on the result of the first one, if successful",null,null],[14,"opt!","","`opt!(I -> IResult<I,O>) => I -> IResult<I, Option<O>>`\nmake the underlying parser optional",null,null],[14,"opt_res!","","`opt_res!(I -> IResult<I,O>) => I -> IResult<I, Result<nom::Err,O>>`\nmake the underlying parser optional",null,null],[14,"cond!","","`cond!(bool, I -> IResult<I,O>) => I -> IResult<I, Option<O>>`\nConditional combinator",null,null],[14,"cond_reduce!","","`cond_reduce!(bool, I -> IResult<I,O>) => I -> IResult<I, O>`\nConditional combinator with error",null,null],[14,"peek!","","`peek!(I -> IResult<I,O>) => I -> IResult<I, O>`\nreturns a result without consuming the input",null,null],[14,"tap!","","`tap!(name: I -> IResult<I,O> => { block }) => I -> IResult<I, O>`\nallows access to the parser's result without affecting it",null,null],[14,"pair!","","`pair!(I -> IResult<I,O>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>`\npair(X,Y), returns (x,y)",null,null],[14,"separated_pair!","","`separated_pair!(I -> IResult<I,O>, I -> IResult<I, T>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>`\nseparated_pair(X,sep,Y) returns (x,y)",null,null],[14,"separated_pair1!","","Internal parser, do not use directly",null,null],[14,"separated_pair2!","","Internal parser, do not use directly",null,null],[14,"preceded!","","`preceded!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, O>`\npreceded(opening, X) returns X",null,null],[14,"terminated!","","`terminated!(I -> IResult<I,O>, I -> IResult<I,T>) => I -> IResult<I, O>`\nterminated(X, closing) returns X",null,null],[14,"delimited!","","`delimited!(I -> IResult<I,T>, I -> IResult<I,O>, I -> IResult<I,U>) => I -> IResult<I, O>`\ndelimited(opening, X, closing) returns X",null,null],[14,"delimited1!","","Internal parser, do not use directly",null,null],[14,"delimited2!","","Internal parser, do not use directly",null,null],[14,"separated_list!","","`separated_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nseparated_list(sep, X) returns Vec<X>",null,null],[14,"separated_nonempty_list!","","`separated_nonempty_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nseparated_nonempty_list(sep, X) returns Vec<X>",null,null],[14,"many0!","","`many0!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nApplies the parser 0 or more times and returns the list of results in a Vec",null,null],[14,"many1!","","`many1!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nApplies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"count!","","`count!(I -> IResult<I,O>, nb) => I -> IResult<I, Vec<O>>`\nApplies the child parser a specified number of times",null,null],[14,"count_fixed!","","`count_fixed!(O, I -> IResult<I,O>, nb) => I -> IResult<I, [O; nb]>`\nApplies the child parser a fixed number of times and returns a fixed size array\nThe type must be specified",null,null],[14,"length_value!","","`length_value!(I -> IResult<I, nb>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\ngets a number from the first parser, then applies the second parser that many times",null,null],[14,"tag!","","`tag!(&[T]: nom::AsBytes) => &[T] -> IResult<&[T], &[T]>`\ndeclares a byte array as a suite to recognize",null,null],[14,"is_not!","","`is_not!(&[T:AsBytes]) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes that do not appear in the provided array",null,null],[14,"is_a!","","`is_a!(&[T]) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes that appear in the provided array",null,null],[14,"filter!","","`filter!(&[T] -> bool) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes until the provided function fails.",null,null],[14,"take_while!","","`take_while!(&[T] -> bool) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes until the provided function fails.",null,null],[14,"take_while1!","","`take_while1!(&[T] -> bool) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest (non empty) list of bytes until the provided function fails.",null,null],[14,"take_till!","","`take_till!(&[T] -> bool) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes until the provided function succeeds",null,null],[14,"take!","","`take!(nb) => &[T] -> IResult<&[T], &[T]>`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"take_str!","","`take!(nb) => &[T] -> IResult<&[T], &str>`\nsame as take! but returning a &str",null,null],[14,"take_until_and_consume!","","`take_until_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>`\ngenerates a parser consuming bytes until the specified byte sequence is found, and consumes it",null,null],[14,"take_until!","","`take_until!(tag) => &[T] -> IResult<&[T], &[T]>`\nconsumes data until it finds the specified tag",null,null],[14,"take_until_either_and_consume!","","`take_until_either_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>`\nconsumes data until it finds any of the specified characters, and consume it",null,null],[14,"take_until_either!","","`take_until_either!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"bits!","","`bits!( parser ) => ( &[u8], (&[u8], usize) -> IResult<(&[u8], usize), T> ) -> IResult<&[u8], T>`\ntransforms its byte slice input in a bit stream for the underlying parsers",null,null],[14,"bits_impl!","","Internal parser, do not use directly",null,null],[14,"take_bits!","","`take_bits!(type, nb) => ( (&[T], usize), U, usize) -> IResult<(&[T], usize), U>`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"tag_bits!","","",null,null],[14,"pusher!","","Prepares a parser function for a push pipeline",null,null],[14,"u16!","","if parameter is true, parse a big endian u16 integer,\notherwise a little endian u16 integer",null,null],[14,"u32!","","if parameter is true, parse a big endian u32 integer,\notherwise a little endian u32 integer",null,null],[14,"u64!","","if parameter is true, parse a big endian u64 integer,\notherwise a little endian u64 integer",null,null],[14,"i16!","","if parameter is true, parse a big endian i16 integer,\notherwise a little endian i16 integer",null,null],[14,"i32!","","if parameter is true, parse a big endian i32 integer,\notherwise a little endian i32 integer",null,null],[14,"i64!","","if parameter is true, parse a big endian i64 integer,\notherwise a little endian i64 integer",null,null],[14,"one_of!","","matches one of the provided characters",null,null],[14,"none_of!","","matches anything but the provided characters",null,null],[14,"char!","","matches one character: `char!(char) => &[u8] -> IResult<&[u8], char>",null,null],[11,"run","","",17,{"inputs":[{"name":"consumer"},{"name":"producer"}],"output":null}]],"paths":[[4,"ErrorCode"],[4,"Err"],[4,"Needed"],[4,"IResult"],[4,"ProducerState"],[4,"StepperState"],[4,"ConsumerState"],[3,"AccReader"],[3,"FileProducer"],[3,"MemProducer"],[3,"ReadProducer"],[3,"Stepper"],[8,"HexDisplay"],[8,"AsBytes"],[8,"GetInput"],[8,"GetOutput"],[8,"Producer"],[8,"Consumer"]]};
initSearch(searchIndex);
